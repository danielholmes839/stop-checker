scalar DateTime     # Input/Output: "2022-07-28T06:30:00Z"
scalar Date         # Input/Output: "2022-07-28"
scalar Time         # Output: 6:30pm, 8:30am...
scalar Color 

enum ScheduleMode {
    ARRIVE_BY
    DEPART_AT
}

enum RouteType {
    BUS
    TRAIN
}

type Location {
    latitude: Float!
    longitude: Float!
    distance(location: LocationInput!): Float!
}

type Stop {
    id: ID!
    name: String!
    code: String!
    location: Location!
    routes: [StopRoute!]!
}

type StopRoute { 
    stop: Stop!
    route: Route!
    direction: ID!
    headsign: String!
    schedule: StopRouteSchedule!
}

type StopRouteSchedule {
    next(limit: Int!): [StopTime!]!
    on(date: Date!): [StopTime!]!
}

type Route {
    id: ID!
    name: String!
    text: Color!
    background: Color!
    type: RouteType!
}

type Trip {
    id: ID!
    route: Route!
    stopTimes: [StopTime!]!
    service: Service!
    direction: ID!
    headsign: String!
}

type StopTime {
    id: ID!
    stop: Stop!
    trip: Trip!
    time: Time!
    sequence: Int!
}

type Service {
    sunday: Boolean!
    monday: Boolean!
    tuesday: Boolean!
    wednesday: Boolean!
    thursday: Boolean!
    friday: Boolean!
    saturday: Boolean!
    start: Date!
    end: Date!
    exceptions: [ServiceException!]!
}

type ServiceException {
    added: Boolean!
    date: Date!
}

# Travel schedule leg
type TravelScheduleLeg {
    origin: Stop!
    destination: Stop!
    walk: Boolean!
    distance: Float!
    transit: Transit            # if null then walking
    duration: Int!
    departure: DateTime!
    arrival: DateTime!
}

type TravelSchedule {
    legs: [TravelScheduleLeg!]!
    origin: Stop!
    destination: Stop!
    duration: Int! 
    departure: DateTime! # origin departure time
    arrival: DateTime! # destination arrival
}

# Travel route leg
type TravelRouteLeg {
    origin: Stop!
    destination: Stop!
    walk: Boolean!
    distance: Float!
    route: Route                # if null then walking - maybe this could be a StopRoute
}

type TravelRoute {
    legs: [TravelRouteLeg!]!
    travelSchedule(mode: ScheduleMode!, dt: DateTime): TravelSchedule # null when the schedule planner fails. 
}

# Transit taken by a scheduled leg
type Transit {
    route: Route!
    trip: Trip!
    departure: StopTime!
    arrival: StopTime!
}

input TravelLegInput {
    origin: ID!
    destination: ID!
    route: ID # if the route id is null then walk
}

type TravelPayload {
    travelRoute: TravelRoute
    errors: [UserError!]!
}

type StopSearchPayload {
    page: PageInfo!
    results: [Stop!]!
}

input LocationInput {
    latitude: Float!
    longitude: Float!
}

type UserError {
    field: String!
    message: String!
}

type PageInfo {
    cursor: Int!   # how many to skip next time
    remaining: Int!
}

input PageInput {
    skip: Int!
    limit: Int! # use a negative number to disable the limit
}

type Query {
    # simple
    stop(id: ID!): Stop

    # search
    searchStopText(text: String!, page: PageInput!): StopSearchPayload! 
    searchStopLocation(location: LocationInput!, radius: Float!, page: PageInput!): StopSearchPayload! 
    
    # travel planner finds a route
    travelPlanner(origin: ID!, destination: ID!, departure: DateTime): TravelPayload!

    # travel scheduler using a pre-defined route
    travelScheduler(route: [TravelLegInput!]!): TravelPayload!
}